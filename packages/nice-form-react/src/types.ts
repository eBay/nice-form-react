import { ReactElement, ReactNode, ComponentProps } from 'react';

export type ReactComponent = (props: ComponentProps<any>) => ReactNode;

export type NiceFormWidgetProps = Record<string, any>;

export type FieldMetaConverter = ({
  meta,
  field,
}: {
  meta: NiceFormMeta;
  field: NiceFormField;
}) => NiceFormField;

// Each field should handle below props
//  {
//   disabled?: boolean;
//   required?: boolean;
//   children?: ReactNode;
//   label?: ReactNode;
//   help?: ReactNode;
//   fullWidth?: boolean;
// }

/**
 * The form field meta. Note that this is the base meta that should be implmented by all adapters.
 * But different adapters may extend the basic meta to have more options.
 */
export interface NiceFormField extends Record<string, unknown> {
  /**
   * The field key. It's used to identify the field. It's used as the field name if the name
   * is not defined. In this case, the name is generated by splitting the key by '.'.
   * For example: if the key is 'user.name', the name will be ['user', 'name'].
   * So it's convenient to support nested object.
   *
   * Note: if you want a dot `.` to be part of the field name, you should specify the name explicitly.
   * For example: name: ['user', 'name.with.dot']
   */
  key: string;

  /**
   * The name of the field, its format may be different for different adapters.
   * For example, in antd, it's an array of path. See API doc of the library you use.
   */
  name?: string | Array<string>;

  /**
   * The label of the field, adapters should implement the support for labels.
   */
  label?: ReactNode;

  /**
   * Help information of the field, consumed by adapter.
   */
  help?: ReactNode;

  /**
   * Whether the field is required.
   */
  required?: boolean;

  /**
   * Whether the field is disabled.
   */
  disabled?: boolean;

  /**
   * Whether the field is full width of the space.
   */
  fullWidth?: boolean;

  /**
   * The initial value of the field.
   */
  initialValue?: any;

  /**
   * The extra node of the field. Appended just after the field component.
   * You usually need to use css to position it.
   */
  extraNode?: ReactNode;

  /**
   * The label width.
   */
  labelWidth?: string;

  /**
   * Only for field widget which consumes a list data.
   * For example: select, checkbox group, radio group, etc.
   */
  options?: any[];

  /**
   * Nice form provides the grid layout system, colSpan is used to specify how many
   * columns of the field.
   */
  colSpan?: number;

  /**
   * Nice form provides the grid layout system, colSpan is used to specify how many
   * rows of the field.
   */
  rowSpan?: number;

  /**
   * If the field is in view mode, it will use viewWidget to render the field.
   * Note that this is different with readOnly property which passes readOnly to the
   * field component.
   */
  viewMode?: boolean;

  /**
   * If the field widget accepts the children, then you can specify it by this.
   */
  children?: ReactNode | Function;

  /**
   * In the grid layout system, if the field allows other fields in `left`, `right` or `both`
   * position. For example, if clear is `right`, then no other fields in the `right` even
   * there's still space (by columns).
   */
  clear?: 'left' | 'right' | 'both';

  /**
   * You can use `render` method to render any content of the field in both edit and view mode. It will replaces
   * the logic provided by adapters. You need to handle the edit/view mode in the function.
   * @param param0
   * @returns
   */
  render?: ({ field, meta }: { field: NiceFormField; meta: NiceFormMeta }) => ReactElement | null;

  /**
   * You can use `renderView` method to render the widget (without label).
   * @param value
   * @param param1
   * @returns
   */
  renderView?: (
    value: any,
    { field, meta }: { field: NiceFormField; meta: NiceFormMeta },
  ) => ReactElement | null;

  /**
   * The widget type.
   */
  widgetType?: string | null;

  /**
   * The widget component or widget id in edit mode.
   */
  widget?: string | ReactComponent | null;

  /**
   * The edit mode widget component props.
   */
  widgetProps?: NiceFormWidgetProps;

  /**
   * The widget component or widget id in view mode.
   */
  viewWidget?: string | ReactComponent | null;

  /**
   * The view mode widget component props.
   */
  viewWidgetProps?: Record<string, any>;

  /**
   * A function returns true or false to determine if the field should be rendered.
   * It's convenient to show/hide fields dynamically.
   *
   * If you need complex logic, you can modify meta fields directlly after meta is constructed.
   * @param param0
   * @returns
   */
  condition?: ({ field, meta }: { field: NiceFormField; meta: NiceFormMeta }) => boolean;
}

/**
 * This is normalized form field meta for internal usage. Usually not used by end users.
 * It ensures the meta always has name/widget/viewWidget defined.
 */
export interface NormalizedFormField extends NiceFormField {
  name: string | Array<string>;
  options?: { label: ReactNode; value: any; [key: string]: any }[];
  widget: string | ReactComponent;
  viewWidget: string | ReactComponent;
}

/**
 * The nice form meta to define the form layout and fields.
 */
export interface NiceFormMeta extends Record<string, any> {
  /**
   * If you have mulitple forms in one page, you may set different names so that fields ids will not conflict.
   */
  name?: string; // used as prefix for form field id

  /**
   * How many columns in the grid layout system.
   */
  columns?: number;

  /**
   * The label width of the field. It differs when using different adapters.
   * For example, you can use 1-24 in antd, but it's unncessary in MUI.
   */
  labelWidth?: number | string; // 1-24

  /**
   * The column gap of the grid layout system.
   */
  columnGap?: string | number;

  /**
   * The row gap of the grid layout system.
   */
  rowGap?: string | number;

  /**
   * Whether the form is disabled (means all fields are disabled)
   */
  disabled?: boolean;

  /**
   * ?
   */
  layout?: any;

  /**
   * Whether the form is in view mode. If true, all fields will be rendered with viewWidget.
   */
  viewMode?: boolean;

  /**
   * The default widget component or widget id for fields in edit mode. This overrides the defaultWidget in config.
   */
  defaultWidget?: string | ReactComponent | null;

  /**
   * The default widget component or widget id for fields in view mode. This overrides the defaultViewWidget in config.
   */
  defaultViewWidget?: string | ReactComponent | null;

  /**
   * Deprecated.
   */
  wrapperProps?: Record<string, any>;

  /**
   * The initial values of the form.
   */
  initialValues?: Record<string, any>;

  /**
   * The fields of the form.
   */
  fields: NiceFormField[];
}

/**
 * This is the normalized form meta for internal usage. Usually not used by end users.
 * It ensures the meta always has fields defined.
 */
export interface NormalizedFormMeta extends NiceFormMeta {
  fields: NormalizedFormField[];
}

/**
 * The widget map to define the widget name and its component.
 * It's usually for internal usage only.
 */
export interface NiceFormWidgetMap {
  [key: string]: {
    /**
     * The component of the form field.
     */
    widget: ReactComponent;

    /**
     * Before rendering, convert user input meta to the meta that the widget needs.
     * @param param0
     * @returns
     */
    metaConverter?: ({
      field,
      meta,
    }: {
      field: NiceFormField;
      meta: NiceFormMeta;
    }) => NiceFormField;
  };
}
/**
 * The adapter for a specific UI/Form state framework.
 * All adapter should handle 'required', 'fullWidth', 'disabled', 'label',
 *  'help' props of a field.
 * You can create an adapter to support other UI frameworks. We have provided
 * antd, formik and formik + MUI adapter.
 */
export interface NiceFormAdapter {
  labelStyle?: React.CSSProperties;

  /**
   * Render the field by NiceFormMeta and NormalizedFormField.
   * @param param0
   * @returns
   */
  renderField?: ({
    meta,
    field,
  }: {
    meta: NiceFormMeta;
    field: NormalizedFormField;
  }) => React.ReactElement | null;
  renderFieldWithoutLabel?: ({
    meta,
    field,
  }: {
    meta: NiceFormMeta;
    field: NormalizedFormField;
  }) => React.ReactElement | null;

  /**
   * Get the field value from the form meta.
   */
  getFieldValue?: (fieldName: string, meta: NiceFormMeta, ...args: any[]) => any;

  /**
   * An adapter can provides additional string to component widget map
   * together with field meta converters..
   */
  widgetMap?: NiceFormWidgetMap;

  /**
   * Process the meta before rendering.
   * @param meta
   * @returns
   */
  processMeta?: (meta: NiceFormMeta) => NiceFormMeta;

  /**
   * Convert user input form meta to the meta that the adapter needs.
   * @param meta
   * @returns
   */
  metaConverter?: (meta: NormalizedFormMeta) => NormalizedFormMeta;

  /**
   * The default widget component or widget id for fields in edit mode.
   */
  defaultWidget?: string | ReactComponent;

  /**
   * The default widget component or widget id for fields in view mode.
   */
  defaultViewWidget?: string | ReactComponent;
}

/**
 * The common config of nice form.
 */
export interface NiceFormConfig {
  // fieldAdapter?: React.FC<Record<string, any>>;
  /**
   * The default widget component or widget id for fields in edit mode.
   */
  defaultWidget: string | ReactComponent;
  /**
   * The default widget component or widget id for fields in view mode.
   */
  defaultViewWidget: string | ReactComponent;
  /**
   * Internal usage only.
   */
  metaConverters: ((meta: NormalizedFormMeta) => NormalizedFormMeta)[];
  /**
   * Internal usage only.
   */
  widgetMap: NiceFormWidgetMap;
  /**
   * Internal usage only.
   * @param param0
   * @returns
   */
  renderField?: ({
    meta,
    field,
  }: {
    meta: NiceFormMeta;
    field: NormalizedFormField;
  }) => React.ReactElement | null;
  renderFieldWithoutLabel?: ({
    meta,
    field,
  }: {
    meta: NiceFormMeta;
    field: NormalizedFormField;
  }) => React.ReactElement | null;

  // readonly adapter: NiceFormAdapter;
  readonly adapters: NiceFormAdapter[];

  /**
   * Add an adapter to the nice form. Nice form could have multiple adapters
   * to provide different features. For example, some adapter supports an UI
   * framework, some adapter supports a form state management framework.
   * @param adapter
   * @returns
   */
  addAdapter: (adapter: Partial<NiceFormAdapter>) => void;

  /**
   * Define a widget so that you can use a string id as field widget.
   * Also you can provide a meta converter to convert user input meta
   * to the meta that the widget needs.
   * @param name
   * @param widget
   * @param metaConverter
   * @returns
   */
  defineWidget: (
    name: string,
    widget: ReactComponent,
    metaConverter: ({ meta, field }: { meta: NiceFormMeta; field: NiceFormField }) => NiceFormField,
  ) => void;

  /**
   * Internal usage only.
   * @param widget
   * @returns
   */
  getWidgetDef: (widget: string | ReactComponent) => {
    widget: string | ReactComponent;
    metaConverter?: FieldMetaConverter;
  };
}
